#!/usr/bin/env python3
# -*- coding:utf-8 -*-

import socket

import time
import random
import struct
import io

class C0S0:
    _version = 3
    def get_version(self):
        return self._version

    def get_message(self):
        return self._version.to_bytes(1, 'little')

class C1S1:
    _timestamp = 0
    _random = 0
    _zero = 0
    def __init__(self, timestamp):
        self._timestamp = timestamp
        self._random = random.getrandbits(1528 * 8)
        self._zero = 0

    def get_message(self):
        return self._timestamp.to_bytes(4, 'big') + self._zero.to_bytes(4, 'little') + self._random.to_bytes(1528, 'little')

    def get_time(self):
        return self._timestamp

class amf0Parse():
    def __init__(self, binary):
        result = []
        byteio = io.BytesIO(binary)
        while(True):
            message_type = byteio.read(1)
            if (message_type == b''):
                break
            if (int(message_type.hex(),16) == 2):
                length = byteio.read(2)
                body = byteio.read(int(length.hex(), 16))
            elif (int(message_type.hex(),16) == 3):
                body = self._object_parse(byteio)
            else:
                body = byteio.read(8)
            result.append(body)
        self.parsed = result
        print(self.parsed)

    def _object_parse(self, byteio):
        result = {}
        while(True):
            key_length = byteio.read(2)
            if (int(key_length.hex(),16) == 0 and int(byteio.read(1).hex(),16) == 9):
                break
            key_body = byteio.read(int(key_length.hex(), 16))
            value_amf0_type = byteio.read(1)
            if (int(value_amf0_type.hex(), 16) == 2):
                # string
                value_length = byteio.read(2)
                value_body = byteio.read(int(value_length.hex(), 16))
            else:
                value_body = byteio.read(8)

            result[key_body] = value_body
        return result

    
    
class amf0():
    def __init__(self, message_type, message):
        self.type_mapping = {
            'string' : 2,
            'number' : 0,
            'object' : 3
        }
        self.message_type = message_type
        self.message = message
        
    def get_byte(self):
        # type(1byte) + length(2byte) + value(length)
        if (self.message_type == 'number'):
            body = struct.pack('>d', self.message)
            byte_message = (self.type_mapping[self.message_type]).to_bytes(1,'big') + body
        elif(self.message_type == 'object'):
            byte_message = (self.type_mapping[self.message_type]).to_bytes(1,'big')
            for object_key in self.message:
                byte_message += (len(object_key)).to_bytes(2,'big') + object_key
                byte_message += (0x02).to_bytes(1,'big') + (len(self.message[object_key])).to_bytes(2,'big')  + self.message[object_key] # TODO string type
        else:
            body = self.message
            byte_message = (self.type_mapping[self.message_type]).to_bytes(1,'big') + (len(body)).to_bytes(2,'big')  + body
        return byte_message

class Rtmp:
    def do_handshake(self, sock):
        # send c0c1
        c0 = C0S0()
        c1 = C1S1(int(time.time()))
        sock.sendall(c0.get_message() + c1.get_message())

        # recv s0
        s0 = sock.recv(1)
        #print('  version: %s' % s0.hex())

        # recv s1
        s1_time = sock.recv(4)
        #print('  time: %s' % int(s1_time.hex(), 16))
        s1_zero = sock.recv(4)
        s1_random = sock.recv(1528)

        # recv s2
        s2_time = sock.recv(4)
        #print('  time: %s' % int(s2_time.hex(), 16))
        s2_time2 = sock.recv(4)
        #print('  time2: %s' % int(s2_time2.hex(), 16))
        s2_random = sock.recv(1528)
        
        # send c2
        sock.sendall(s2_time + s2_time + s2_random)

        return True
        
    def do_connect(self, sock):
        # RTMP body
        connect_message = amf0('string', b'connect').get_byte()
        number1_message = amf0('number', 1).get_byte()
        object_message = amf0('object', {
            b'app':b'live',
            b'tcUrl': b'rtmp://localhost:1935/live',
            b'flashVer': b'FMLE/3.0 (compatible; Lavf58.20.100)'
        }).get_byte()
        object_end = 0x09.to_bytes(3,'big')
        rtmp_body = connect_message + number1_message + object_message + object_end

        # RTMP header
        timestamp = 0
        body_length = len(rtmp_body)
        type_id = 0x14 # AMF0
        stream_id = 0
        basic_header = (0x3).to_bytes(1, 'big')
        message_header = timestamp.to_bytes(3, 'big') + body_length.to_bytes(3, 'big') + type_id.to_bytes(1,'big') + stream_id.to_bytes(4, 'little')
        
        sock.sendall(basic_header + message_header + rtmp_body)

        # result
        amf0Parse(self._recv(sock))
        amf0Parse(self._recv(sock))
        amf0Parse(self._recv(sock))
        amf0Parse(self._recv(sock))
        

    def _recv(self,sock):
        chunk_stream_id = sock.recv(1) # TODO fmt!=0
        timestamp = sock.recv(3)
        message_length = sock.recv(3)
        message_type_id = sock.recv(1)
        message_stream_id = sock.recv(4)
        body = sock.recv(int(message_length.hex(), 16))
        return body


if __name__ == '__main__':
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect(('localhost', 1935))
    rtmp = Rtmp()
    rtmp.do_handshake(sock)
    rtmp.do_connect(sock)
    sock.close()
